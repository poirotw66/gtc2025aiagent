Hello,大家好,今天我们给大家带来的分享是利用英伟达的Optics 7开发一款分布式光照烘焙系统,能助力游戏项目获得高质量、高性能的全局光照效果。本次分享将由我和另外一位同事正元一起给大家进行分享。我是来自腾讯游戏前沿技术中心的客户端负责人李超。2019年我博士毕与政经大学基层神技学院,一直从事的是图形图像相关的研发工作,目前也是MagicDone的负责人。正元是我们MagicDone核心的开发同学。本次分享主要包含三大块,首先是当前游戏GI发展的一些现状和挑战,其次是MagicDone这款跨引擎分布式光照烘焙系统的详细介绍,最后是关于游戏GI未来的一些发展的一些展望。我主要作为开场介绍第一部分,后面这详细的内容由正元同学给大家进行介绍。现在我们开始第一部分的介绍,当前游戏GI发展的现状和挑战。这边是我我们总结的当前已经上新的一些游戏,在光照方面的选行。大部分是设计类游戏,因为这类游戏通常对画面质量的追求比较高。大家可以看到,基本上每款游戏的光照,不管是PC还是移动端,都有理性预烘焙的一些例子。然后辅助一些类似于IBL和实时光,补一些高频的光照。光照载体也可以是Netmap和NetPro.实时和理性预计算相结合的方式,作为我们光照烘焙的解决方案,也是最务实的一种方式。我们常说的游戏光照可分为直接光和经济光两部分。经济光又包含Diffuse GI和Specular GI,其中Specular GI的计算比较简单,而Diffuse GI则是计算比较复杂的部分,也就是我们广义说指的游戏GI。这部分的计算可以采用实时计算的方式,也能用烘焙的方式进行计算。这两种方式,它们的载体有所不同。一般烘焙GI的载体密度更高,效果更好,但是计算也是最费时的。而实时GI可以通过实时计算的方式进行光照注入,将两种GI进行统一的比较我们发现。烘焙GI的优势在于它能提供一个更好的效果,不同平台可以采用统一的GI管线。同时,实时计算的开销也比较小。不足点在于,离线计算比较耗时,会增加游戏的包体。同时,它不支持动态光源和UGC的一些场景。这些不足也是我们MagicDun所要克服的。总的来讲,不管是实时GI还是烘焙GI,它们本质上都是由于计算资源的受限,而对真实感受缘的一些近视。这两张图是AI画的两张形象的对比图。烘焙GI在离线制作过程中比较麻烦,但是运行时比较轻量和简单,而实时GI在离线制作的过程中相对简单,但是运行时的性能管线比较复杂。我们之所以选择烘焙GI这条路线,主要有三点考虑。第一,游戏的玩法永远是最核心的要素。第二,在游戏性能面前,所有的效果都可以抛弃。第三,游戏GI是提升游戏画质性价比最高的方案。因此,我们选择了一条就是能够提供高质量、低开销的GI路径,也希望借助英伟达的Optic 7来克服传统光照烘焙过程中的不足,给玩家带来更真实的一些游戏GI效果。第二大块主要是介绍MagicDone的一些特性和详细的一些技术方案。我们有请我们正元同学给大家进行介绍。我们知道,高品质的GI对于游戏的真实感是十分重要的。然而,高品质的GI烘焙是一个十分耗时的任务。在电影行业,渲染一帧的时间可以花上数百个小时。而在大型游戏项目中,一个关卡甚至要烘上个好几天。目前,业内的GI烘焙工具各有各的局限性,还未出现优势明显一统天下的商业产品。我们这里列举了一些业内常用的烘焙工具。我们可以看到,除了MagicDone之外,它们之中只有LightMath支持分布式烘焙。而LightMath是利用CPU来计算的。我们的解决方案MagicDone是一套利用了NVIDIA的Optics 7光线追踪引擎的分布式光照烘焙系统。通过多GPU的连机并行,同时达成高质量和高速率的烘焙效果。我们团队也与超过20个一线游戏制作团队合作过,深入了解过它们在光照烘焙上的痛点。MagicDone正是为了解决这些痛点问题而出生的。MagicDone支持游戏制作中会出现的多种烘焙场景。包括最经典的光照贴图LightMath以及体积光照方案,就比如说虚幻引擎的VLM和ILC。其中LightMath可以给静态物体提供高质量的全距光照信息,但是它给存储和包体带来的开销更大。而体积光照方案可以给动态的物体接受静态的全距光照。相应的,它给存储和包体带来的开销较小。因为体积光照方案有包体更小,制作流程更简单。就比如说不用像LightMath一样展开物体的UV这样的优势。所以MagicDone也支持一种跨平台通用的逐像素的体积光照系统。我们叫做CLV,Cascade Lighting Volume。同时,MagicDone还支持输出PRT,也就是预计算光照传输的数据。这使得我们可以支持动态的天光和阻光的全距光照,也就是说支持TOD的一些应用。总的来说,MagicDone作为一款分布式光照烘焙系统,大幅度提升了烘焙效率。我们在多个场景下的实测数据显示,单卡效率提升约6倍,整体效率提升有将近40倍之多。而这套系统的主要特性有,一、大世界任务拆封与规划,即自动拆封大世界场景,避免出现单卡报线存的问题,以及自动规划任务,最小化管线的再次创建。二、光源管理,MagicDone支持害量光源,虚拟光源和自发光物体的数量没有上线。三、TOD的支持,MagicDone支持输出PRT数据,这个特性支持适合一些需要使用动态天光和主光的TOD应用。四、分布式联机烘焙的效率,甚至支持一些在UGC场景下的烘焙应用。五、有一套完整的分布式节点监测系统,支持自组烘焙服务器以及集群,还有支持断点续传和自动重联。六、我们发现在日常使用过程中,造成问题最多的还是游戏资产本身的问题,就比如光图UV分配不合理导致的漏光等。所以我们也提供了一些资产检查的小工具,来避免这些错误。接下来,我将展示MagicDone的整体结构。MagicDone主要分为四大模块。首先,是左上角引擎侧的插件。它负责配置烘焙任务的参数。在烘焙启动时,这个插件会收集并导出场景中的模型、材质和光源为文件,发送给在服务器上运行的Coordinator。同时,DoneHive这个客户端独立的进程会被拉起,提供给美术人员实施的烘焙进度反馈。Coordinator则会把不同的任务,根据任务的类型和消耗,分发给不同的agent来执行。同时,运行在服务器上的节点监视器,会实时地收集各种agent运行的统计数据,以供后续地分析。这里展示了MagicDone的架构依赖图。上层的模块依赖下层的模块。这个系统的最下层是Cuda、Optics7、Volkan等API。Cuda和Optics7是光线追踪的核心,而Volkan则是被用在硬件光纱化Light Map上。因为这些API都把资源管理交给用户自己负责,所以我们实现了一套资源管理图,也就是RDG的系统。它可以根据资源之间的依赖情况自动地管理资源的生命周期。在这个之上是一个BakingContext,里面含有当前节点各种整个烘焙任务过程中需要的资源,比如场景的BVH、SBC的BundingTable等等。还有就是各自烘焙任务的Lunches。最上层的部分就是各种导入导出、场景拆分等高层逻辑了。接下来,我来介绍一下Optics 7给我们带来了什么。我认为很大程度上就是自由的资源管理。我们上一代Dumb蓬贝器是基于Optics 6的。我们最初升级Optics 7的目的,就是看到Optics 7是一个更加现代化的API。然后我们就发现,如果只是单纯的替换掉API的话,并不太足够。因为Optics 6和7在概念上的差别实在是太大了。Optics 7的最佳实践是,用户直接使用Kuda API来自己管理资源。最后,我们几乎重写了整个烘焙系统。因为我们需要自行管理资源,所以一个资源管理的中间层,对于后续烘焙PaaS的开发会带来非常多的方便。RDG这个名字,借用自虚幻引擎同名的资源管理设施,Resource Dependency Graph。RDG Allocator把底层的Kuda API Cores包装,加上了生命周期追踪。各个PaaS在引用RDG管理的资源的时候,RDG就能自动知道哪些资源被谁用了多久,进而分析出资源可以在哪里,什么时候被释放,以及哪些PaaS之间不存在资源依赖,可以并行执行。那么,我们的烘焙系统在扩展到大世界烘焙任务的时候,又遇到了哪些挑战呢?我们来看这样一个案例,一个十几公里乘十几公里的大世界场景,有41个三角面,300万个物体,52万Light Maps。如果直接烘焙的话,那瞬间就会撑爆显存。而因为Light Maps实在太多,如果将所有Light Maps在烘焙完成后一起导入回发起烘焙的客户端的话,那那个客户端的内存也会爆掉。其次,在烘焙过程中,有许多非常小的任务,比如说瓶瓶罐罐什么的。这些小任务因为GPU的负载较低,反而会带来非常大的CPU的额外开销。如果说我们对原始场景,按照面积区域均匀的切分场景的话,也会造成问题。一是重叠的子关卡会重复烘焙,二是由于场景内物件密度的不均匀,仍然会有爆现存以及爆内存的风险。我们的解决方法是,自适应地根据区域内的物体数量拆分场景。还有,就是把同一子关卡的任务发配到同一个agent上执行。这样子的话,我们就可以最小化BVH的构建。相比之下,在BACA的情况下,场景拆分前,我们需要超过20G的显存。在拆分后,单卡上只需要1.5到4G。而烘焙的时间则从超过20个小时,缩短到3个小时左右。更进一步的,因为不同规模的任务GPU负载不均,过小的任务会带来CPU的额外开销,而过大任务则会称报显存。所以我们采用了均匀任务组装的方式。简单来说就是,组合过小的任务,拆分过大的任务。这使得所有任务都有一致的大小。这也保证了我们只要多增加节点,就一定能够缩短总的烘焙时间。所以从这张实验的表格中,我们可以看到,我们的节点数乘倍的增加,而我们优化过的时间则成倍的减少。烘焙的另一个重要阶段就是降噪。我们使用了Optics的AI降噪器。相比于带Edge Doping的双边滤波,Optics的AI降噪器更加不容易发生漏光的现象。所以,我们先采用AI降噪器大范围进行了一遍降噪,然后再用一个很小的Footprint的双边滤波器,进一步平滑结果。Optics AI降噪器不仅能够降噪常见的Invedience信息,还能够处理方向性信息。比如说,在某些烘焙场景下,我们需要烘焙光照来源的方向,或者天光的SkyBitnormal的方向。我们发现,在使用AI降噪器的时候,将-1到正1范围内的数值,拆分成正的部分和负的部分,然后分别降噪它们的绝对值,再用相减的方式组合还原回去,能够更加稳定地获得降噪的结果。这就是我们在每像素256样本下的降噪结果。右边是未降噪的结果,而左边是降噪了的结果。我们可以发现,AI降噪器,它十分稳定地解决了右边未降噪时候的高频噪声,同时它也没有引入露白露黑等问题。除此之外,我们还提供了多种类型的光源支持,适合游戏中的多种应用场景。接下来,我将整体展示DAM的静态烘焙效果。请不吝点赞 订阅 转发 打赏支持明镜与点点栏目。请不吝点赞 订阅 转发 打赏支持明镜与点点栏目。请不吝点赞 订阅 转发 打赏支持明镜与点点栏目。这可以使得美术团队对烘焙器的效果有一个稳定的期望。DAM现在已经成为Unity中国的官方云烘焙提供者。在这里我们展示了Unity引擎下的烘焙效果。这里展示的是在三个真实的项目中Matchdown的烘焙效率。可以看到在不同大小的地图中,使用8卡分布式烘焙和基于Optics 7的Magic DAM的烘焙时间远远小于LightMath。接下去,我将介绍一些Magic DAM的高级功能。首先是PRT2.0。PRT是一种烘焙物体间光照传输的技术。可以做到无需烘焙多套数据即可实现动态的昼夜变化。相比于一般的记录完整的TransferMatrices的PRT。PRT2.0通过拆分高频信息到LightMap上,低频信息到Prob上,大大缩小了所需的存储开销。这是一段PRT2.0的效果展示。我们可以看到动态的昼夜天气光照的变化。另一个高级的功能是纯体即光照。虽然LightMaps已经很成熟,但是它的局限性也很明显。比如说,需要非常小心地处理UV才能够防止出现漏光。还有就是容易出现黑边等瑕疵。而基于纯粹Prob的GI,则在制作上简单得多。然而,纯Prob GI的问题是细节表格不丰富,漏光和为了解决这些问题所带来的高额运行式开销。我认为,和我们长期耕耘的离线烘焙类似,离线的AI优化技术将助力纯Prob GI成为一种从低端到高端全平台可用的方案。比如说,我们在使用AIProb压缩,可以做到远低于传统压缩算法的压缩率。而针对漏光问题,则可以通过离线优化Volume分割的方式进去。这些解决方案的共同点都是把大量的计算时间从运行时提前到了制作烘焙的阶段,从而让低端的设备也可以运行。从这张直方图中我们可以看到,纯Prob的方案,比如说龟色的VLM和红色的CLV,相较于LightMap方案,在游戏包体的方面具有巨大的优势。而这得益于MagicDom所使用的AI压缩技术。我们可以看到,这边是AI压缩算法的结果,而这边是传统算法的结果。我们可以看到,AI压缩算法在获得更高的压缩率的同时,它也还原出了一些传统压缩算法所丢失的细节信息。下面我们来看看离线防漏光光照体积优化的效果。我们可以看到,相比于完全不做处理的体积光照,经过离线优化后的体积光照,大幅减小了薄墙附近的漏光问题。由于虚幻引擎在移动端上的体积光照实现更加简单,所以漏光的问题也更加明显。而经过离线优化的体积光照,由于它不占用运行时的计算资源,在移动端上也能够运行,并且得到防漏光的效果。以下是一些使用了Magic Dumb的游戏或者应用。它们中的很多都使用了Static Baking,有部分使用了PRT,以达到实现TOD的效果。最后,我们来展望一下我们对于游戏GI在未来的发展。目前,随着硬件性能的不断提高,越来越多的游戏正在转向全实时的GI,但我们认为烘焙GI其实并不与之发生冲突。全平台统一的GI管线的重要性会愈发得明显,烘焙GI和实施GI的优势将紧密地结合。随着AI技术的发展,烘焙GI的概念将扩展为预处理GI,它和实施GI的关系就会变得像AI的训练和部署一样。比如说,预处理GI结合AI压缩、降噪、超风技术,包体将会急剧地减小,而效果将会极大的提升,而可以运行时带来更多的减负。而对于高端机型来说,实施光追将会变得更加普及。以上就是我们今天分享的全部内容。谢谢大家。